from random import betavariate
import numpy as np
import networkx as nx

# **********************************
# GRAPH AND INTERACTION
# **********************************

# We analyze two random graph structures. A random graph starts without any edge, and it is built adding successive 
# edges between the nodes with a procedure that satisfies some requirement given for the specific model. 

# One model that we use is the so-called Gnm random graph: 
# one of the variants of the Erdös Renyi model in which a 
# graph is chosen uniformly at random among all possible graphs with n nodes and m edges. We generate the adjacency matrix of this set of 
# graphs from a fixed density \rho with which the number of edges is calculated as m = ceiling(\rho(n^2-n)/2). 

# The other lattice structure in our study is known as random r-regular graph:
# it is defined by the fact that every node has exactly r neighbors. The number of neighbors r is 
# also called coordination number or degree Z. The total number of edges in a r-regular graph is given by r*n/2, where n is the number of vertices, 
# and therefore r*n must be even.  

# In practice, all the graphs were randomly generated by the python package networkx. Each graph defines a connectivity matrix, 
# where the non-zero elements are then drawn from a normal distribution such that Q[i,j],J[i,j]~N(0,\sigma^2) for i,j neighbors and otherwise 
# Q[i,j],J[i,j] = 0.


def generate_graph(N, graph, argument):
    if graph == "Gnm": # Gnm random graph
        density = argument
        edges = density * (N ** 2 - N) / 2
        G = nx.gnm_random_graph(n=N, m=edges)
    else: # r-regular random graph
        degree = argument
        G = nx.random_regular_graph(d=min(degree, N), n=N)
    return nx.to_numpy_matrix(G)


def generate_interaction(N, problem_type_name, graph_type, graph_argument):
    W = generate_graph(N, graph_type, graph_argument)
    JorQ = np.array(W) * np.random.normal(loc=0, scale=1, size=(N, N))
    JorQ = (JorQ + JorQ.T) / 2.0
    h = np.random.normal(loc=0, scale=1, size=N)

    problemtypes = {"QUBO": Q_to_E_QUBO, "Random_Ising": Q_to_E_Ising, "MAXCUT": Q_to_E_MAXCUT, "SK": Q_to_E_MAXCUT}
    problemtype = problemtypes[problem_type_name]

    return problemtype(JorQ, h)

# **********************************
# OPTIMIZATION PROBLEMS
# **********************************

# We face two energy functionals that have the same purpose. In the QUBO
# formalism, we write
#
#   E[x] = \sum_{ij} 2 x[i] Q[i,j] x[j]
#
# In the Ising formalism we write
#
#   E[s] = \sum_{ij} (1/2) s[i] J[i,j] s[j] + \sum_i h[i] s[i]
#
# Since the bits x[i] ϵ {0,1} are related to the spins s[i] ϵ {-1,1} by
#
#   s = 2*x-1   or  x = (s + 1)/2
#
# We can write
#   E[s] = \sum_{ij} (s[i] + 1)Q[i,j](s[j]+1)/2
#        = \sum_{ij} (1/2) s[i] Q[i,j] s[j] + \sum_{ij} (Q[i,j]+Q[j,i]) s[j]/2
#        +  \sum_{ij} Q[i,j] / 2
#
# This gives a relation between Q and {J,h}
#   J[i,j] = Q[i,j],
#   h[j] = \sum_i (Q[i,j] + Q[j,i]) / 2
#   E = \sum_{ij} (1/2) s[i] J[i,j] s[j] + \sum_i h[i] s[i] = \sum_{ij} 2 x[i] Q[i,j] x[j] - \sum_{ij} Q[i,j] / 2 


def all_bit_strings(N):
    """Return a matrix of shape (2**N, N) of all bit strings that
    can be constructed using 'N' bits. Each row is a different
    configuration, corresponding to the integers 0, 1, 2 up to (2**N)-1"""
    confs = np.arange(2 ** N, dtype=np.int32)
    return np.array([(confs >> i) & 1 for i in range(N)], dtype=np.uint32)


def Q_to_E_QUBO(Q, _):
    """Return the energies of all basis states for a QUBO problem
    defined by the QUBO matrix Q."""
    Q = J = np.array(Q)
    bits = all_bit_strings(Q.shape[0])
    E = 2 * ((Q @ bits) * bits).sum(0)
    E -= (1/2)*Q.sum()
    return E, J


# The MAXCUT problem is slightly different, as it is defined by
#
#   E[x] = \sum_{ij} -2 x[i] Q[i,j] (1 - x[j])
#
# When mapping to the Ising model, this means
#
#   E[s] = \sum_{ij} -(s[i] + 1)Q[i,j](1 - s[j])/2
#        = \sum_{ij} (1/2) s[i] Q[i,j] s[j] + \sum_{ij} (Q[i,j]-Q[j,i]) s[j]/2
#        -  \sum_{ij} Q[i,j] / 2
#
# Since the matrix Q is symmetric, we directly obtain
#   J = Q
#   h = 0
#   E = \sum_{ij} (1/2) s[i] J[i,j] s[j] = \sum_{ij} -2 x[i] Q[i,j] (1 - x[j]) + \sum_{ij} Q[i,j] / 2 


def Q_to_E_MAXCUT(Q, _):
    """Return the energies of all basis states for a MAXCUT problem
    defined by the Ising matrix J."""
    Q = J = np.array(Q)
    bits = all_bit_strings(Q.shape[0])
    E = -2 * ((Q @ bits) * (1 - bits)).sum(0)
    E += (1/2)*Q.sum()
    return E, J

# In the Random Ising problem, we directly generate a random Ising Hamiltonian from J and h defined as
#   E = \sum_{ij} (1/2) s[i] J[i,j] s[j] + \sum_i h[i] s[i]

def Q_to_E_Ising(J, h):
    """Return the energies of all basis states for an Ising problem
    defined by the Ising matrix J and the magnetic field."""
    J = np.array(J)
    spins = 2 * (all_bit_strings(J.shape[0]) - 0.5)
    E = 0.5*((J @ spins) * spins).sum(0)
    E += h @ spins
    return E, J
